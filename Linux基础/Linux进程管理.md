# 经典 Linux 进程管理命令

-  **ps**：查看 Linux 中当前运行的进程的命令。能列出系统中运行的进程，包括进程号、命令、CPU使用量、内存使用量等
    示例：

  ```bash
   ps -a      	- 列出所有运行中/激活进程
   ps -ef |grep  	- 列出需要进程
   ps -aux   		- 显示进程信息，包括无终端的（x）和针对用户（u）的进程：如USER, PID, %CPU, %MEM等
  ```

  

- **pstree** ：linux中每一个进程都是由其父进程创建的。pstree以可视化方式显示进程，通过显示进程的树状图来展示进程间关系。如果指定了pid了，那么树的根是该pid，不然将会是init（pid： 1）。

- **top**：实时的监控系统状态信息和进程所使用的资源。显示进程的数据包括 PID、进程属主、优先级、%CPU、%memory等。可以使用这些显示指示出资源使用量。

- **htop**：htop 与 top 很类似，但是 htop 是交互式的文本模式的进程查看器。它通过文字图形化地显示每一个进程的CPU和内存使用量、swap使用量。使用上下光标键选择进程，F7和F8改变优先级，F9杀死进程。Htop不是系统默认安装的，所以需要额外安装。

- **nice**：通过 nice 命令的帮助，用户可以设置和改变进程的优先级。提高一个进程的优先级，内核会分配更多CPU时间片给这个进程。默认情况下，进程以 0 的优先级启动。进程优先级可以通过 top 命令显示的 NI（nice value）列查看。
  进程优先级值的范围从-20到19。值越低，优先级越高。nice <优先值> <进程名> - 通过给定的优先值启动一个程序

- **renice**：renice 命令类似 nice 命令。使用这个命令可以改变正在运行的进程优先值。
      注意，用户只能改变属于他们自己的进程的优先值。

  ```bash
    renice -n -p - 改变指定进程的优先值
    renice -u -g - 通过指定用户和组来改变进程优先值
  ```

  

- **kill** ：用来发送信号给进程，并结束进程。如果一个进程没有响应杀死命令，这也许就需要强制杀死，使用 -9 参数来执行。
       注意：使用强制杀死的时候一定要小心，因为进程没有时机清理现场，也许写入文件没有完成。
       如果 不知道进程PID 或者 用名字杀死 进程时候，killall 就能派上用场。
        

  ```bash
     kill <pid>         --- 使用 kill 时候，需要知道进程ID号，可以通过 ps 命令得到 进程号
     kill -9 <pid>       --- 杀死进程
     killall -9 <进程名>   --- 杀死所有拥有同样名字的进程
     pkill <进程名>     --- pkill 是类似的命令，但使用模式匹配，如进程名，进程拥有者等。
  ```

  

- **ulimit** ：控制系统资源在shell和进程上的分配量。对于系统管理员是最有用的，可以管理重度使用和存在性能问题的系统。
  限制资源大小可以确保重要进程持续运行，其他进程不会占用过多资源。

  ```bash
      -f - 最大文件尺寸大小
      -v - 最大虚拟内存大小（KB）
      -n - 增加最大文件描述符数量
      -H : 改变和报告硬限制
      -S : 改变和报告软限制
      ulimit -a - 显示当前用户关联的资源限制
  ```

  

- **w** ：显示当前登录的用户及其正在执行的进程的信息。
      显示信息头包含信息，如当前时间、系统运行时长、登录用户总数、过去的1，5，15分钟内的负载均衡数。
      基于这些用户信息，用户在终止不属于他们的进程时要小心。

- **who**： 和 w 类似的命令，提供当前登录用户列表、系统启动时间、运行级别等。

- **whoami** ： 输出当前用户ID。

- **pgrep** ：pgrep 的意思是 " **进程号全局正则匹配输出** "。该命令扫描当前运行进程，然后按照命令匹配条件列出匹配结果到标准输出。对于通过名字检索进程号是很有用。
      示例：pgrep -u mint sh      // 显示用户为 "mint" 和进程名为 "sh" 的进程ID。

- **fg 、bg**：fg 即 frontgroud，表示 前台。 bg 即 background，表示 后台。
    有时命令需要很长时间才能执行完成。对于这种情况，
    使用 "bg" 命令可以将任务放在后台执行。使用 "fg" 命令可以将任务调到前台执行。
    可以通过 & 在后台启动一个程序: find . -name *iso > /tmp/res.txt &
    一个正在运行的程序也可以通过 "CTRL+Z" 和 "bg" 命令组合放到后台运行。

  ```bash
    find . -name *iso > /tmp/res.txt &   // 启动一个程序
    ctrl+z                  // 挂起当前执行程序
    bg                    // 将程序放到后台运行
    可以使用 "jobs" 命令列出所有后台进程。
    jobs
    使用 "fg" 命令可以将后台程序调到前台执行。
    fg %进程id
  ```

  

- **ipcs** ：ipcs 命令报告进程间通信设施状态。（共享内存，信号量和消息队列）
      用 -p 参数联合 -m、-s 或 -q 使用，可以获得相关的进程间通信的进程ID。
      示例：ipcs -p -m

# linux上进程有5种状态

 

5 种进程状态

```markdown
1.  运行        ( 正在运行或在运行队列中等待 ) 
2.  中断        ( 休眠中, 受阻, 在等待某个条件的形成或接受到信号 ) 
3.  不可中断    ( 收到信号不唤醒和不可运行, 进程必须等待直到有中断发生 ) 
4.  僵死        ( 进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放 ) 
5.  停止        ( 进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行 ) 
```

ps 工具标识进程的 5 种状态码: 

```properties
D    不可中断    uninterruptible sleep (usually IO) 
R    运行        runnable (on run queue) 
S    中断        sleeping 
T    停止        traced or stopped 
Z    僵死        a defunct (”zombie”) process
```

# ps 命令常用用法（方便查看系统进程）

示例：

```bash
ps 命令常用用法（方便查看系统进程）
1）ps a   显示现行终端机下的所有程序，包括其他用户的程序。
2）ps -A  显示所有进程。
3）ps c   列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示。
4）ps -e  此参数的效果和指定"A"参数相同。
5）ps e   列出程序时，显示每个程序所使用的环境变量。
6）ps f   用 ASCII 字符显示树状结构，表达程序间的相互关系。
7）ps -H  显示树状结构，表示程序间的相互关系。
8）ps -N  显示所有的程序，除了执行ps指令终端机下的程序之外。
9）ps s   采用程序信号的格式显示程序状况。
10）ps S  列出程序时，包括已中断的子程序资料。
11）ps -t<终端机编号> 　指定终端机编号，并列出属于该终端机的程序的状况。
12）ps -u root 　显示root用户信息
13）ps x 　      显示所有程序，不以终端机来区分。

ps -aux   最常用的方法，然后再利用一个管道符号导向到 grep 去查找特定的进程,
          然后再对特定的进程进行操作。
ps aux    列出目前所有的正在内存当中的程序    
	说明：
        USER：该 process 属于那个使用者账号的
        PID ：该 process 的号码
        %CPU：该 process 使用掉的 CPU 资源百分比
        %MEM：该 process 所占用的物理内存百分比
        VSZ ：该 process 使用掉的虚拟内存量 (Kbytes)
        RSS ：该 process 占用的固定的内存量 (Kbytes)
        TTY ：该 process 是在那个终端机上面运作，若与终端机无关则显示 ?，另外，tty1-tty6 
              是本机上面的登入者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序。
        STAT：该程序目前的状态，主要的状态有
        R ：该程序目前正在运作，或者是可被运作
        S ：该程序目前正在睡眠当中 (可说是 idle 状态)，但可被某些讯号 (signal) 唤醒。
        T ：该程序目前正在侦测或者是停止了
        Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态
        START：该 process 被触发启动的时间
        TIME ：该 process 实际使用 CPU 运作的时间
        COMMAND：该程序的实际指令

ps -ef               显示所有进程信息，连同命令行
ps -ef | grep ssh    ps 与grep 常用组合用法，查找特定进程

ps -l   将目前属于您自己这次登入的 PID 与相关信息列示出来
        说明：
           	各相关信息的意义：
           	F      代表这个程序的旗标 (flag)， 4 代表使用者为 super user
           	S      代表这个程序的状态 (STAT)，关于各 STAT 的意义将在内文介绍
           	UID    程序被该 UID 所拥有
           	PID    就是这个程序的 ID ！
           	PPID   则是其上级父程序的ID
           	C CPU  使用的资源百分比
           	PRI    这个是 Priority (优先执行序) 的缩写，详细后面介绍
           	NI     这个是 Nice 值，在下一小节我们会持续介绍
           	ADDR    这个是 kernel function，指出该程序在内存的那个部分。
                                         如果是个 running的程序，一般就是 "-"
           	SZ      使用掉的内存大小
           	WCHAN   目前这个程序是否正在运作当中，若为 - 表示正在运作
           	TTY     登入者的终端机位置
           	TIME    使用掉的 CPU 时间。
           	CMD     所下达的指令为何
        在预设的情况下， ps 仅会列出与目前所在的 bash shell 有关的 PID 而已，
        所以， 当我使用 ps -l 的时候，只有三个 PID。

ps -axjf    列出类似程序树的程序显示
ps aux | egrep '(cron|syslog)'    找出与 cron 与 syslog 这两个服务有关的 PID 号码
ps -o pid,ppid,pgrp,session,tpgid,comm    输出指定的字段

############################################################
 
注意："ps aux" 和 "ps -aux" 不相同。
      例如："-u" 用来显示该用户的进程。但是 "u" 则是显示详细的信息。
      BSD风格: 在 BSD 风格的语法选项前不带连字符。例如: ps aux 
      UNIX/LINUX的风格：在 linux 风格的语法选项前面有一个 "-"。例如: ps -ef 
      混合使用两种 Linux 系统上的语法风格是好事儿。例如：ps ax -f

1、显示所有进程：
    $ ps ax 
    $ ps -ef
    "u"或者"-f"参数来显示所有进程的详细信息
    $ ps aux 
    $ ps -ef -f 
    注意:为什么用户列不显示我的用户名，但显示其他用户，如root、www等，对于所有的用户名（包括你）
         如果长度大于8个字符，然后ps将只显示UID，而不是用户名。

2、根据用户显示进程：
    由进程的所属用户使用“-u”选项后跟用户名来显示。多个用户名可以提供以逗号分隔。
    $ ps -f -u www-data 

3、通过名字和进程ID显示进程：
    通过名字或命令搜索进程，使用 “-C” 选项后面加搜索词。
    $ ps -C apache2 

4、根据CPU或者内存进行排序：
    “–sort” 选项由逗号分隔的多个字段可以用指定。此外，该字段可以带有前缀“-”或“”符号，
    表示降序或升序分别排序。通过进程列表进行排序有很多参数，你可以检查手册页的完整列表。
    $ ps aux --sort=-pcpu,+pmem 
    $ ps aux --sort=-pcpu | head -5

5、用树的风格显示进程的层次关系：
    许多进程实际上是一些父进程分的分支，知道这父子进程关系往往是有用的。
    在'–forest'选项将建立ASCII艺术风格层次的树视图。
    下面的命令将搜索进程名字为Apache2，形成一个树结构来显示详细的信息。
    $ ps -f --forest -C apache2 

6、显示一个父进程的子进程：
    这里有一个例子显示所有apache进程的分支
    $ ps -o pid,uname,comm -C apache2 

7、显示一个进程的线程：
    “-L”选项将显示进程的线程。它可以用来显示特定进程的所有线程或者所有进程。
    下面的命令将显示所有id为3150的进程所拥有的线程。
    $ ps -p 3150 -L 

8、改变要显示的列：
    ps命令可以配置为只显示选中的列表。为了显示完整列表可以查看手册。
    下面的命令只显示PID，用户名，CPU，内存和命令的列。
    $ ps -e -o pid,uname,pcpu,pmem,comm 
    可以重命名列标签，相当的灵活。
    $ ps -e -o pid,uname=USERNAME,pcpu=CPU_USAGE,pmem,comm 

9、显示进程运行的时间：
    表示进程的运行时间。对于运行的时间，列默认情况下是不显示的，可以使用“-O”选项查看。
    $ ps -e -o pid,comm,etime 

10、把ps命令变成一个实时查看器：
    像往常一样，watch命令可以用来实时捕捉ps显示进程。简单的例子如下:
    $ watch -n 1 'ps -e -o pid,uname,cmd,pmem,pcpu --sort=-pmem,-pcpu | head -15' 
```

 

 